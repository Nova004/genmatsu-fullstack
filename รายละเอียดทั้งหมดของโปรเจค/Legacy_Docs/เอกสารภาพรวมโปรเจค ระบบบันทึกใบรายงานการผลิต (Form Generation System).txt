เอกสารภาพรวมโปรเจค: ระบบบันทึกใบรายงานการผลิต (Form Generation System)
1. ภาพรวมและเป้าหมายหลัก (Project Overview & Goal)
โปรเจคนี้คือ เว็บแอปพลิเคชัน Full-stack ที่ถูกสร้างขึ้นมาเพื่อเปลี่ยนกระบวนการบันทึก "ใบรายงานการผลิต" จากเดิมที่ใช้โปรแกรม Excel มาสู่ระบบดิจิทัลที่ทันสมัย, ยืดหยุ่น, และพร้อมสำหรับการขยายผลในอนาคต
	• เป้าหมายหลัก: สร้างระบบที่ผู้ใช้ทั่วไปสามารถ "กรอก" และ "ดู" ใบรายงานการผลิตได้อย่างง่ายดาย ในขณะที่ผู้ดูแลระบบ (Admin) สามารถ "สร้าง" และ "แก้ไข" โครงสร้างของฟอร์มเหล่านั้นได้ด้วยตัวเอง โดยไม่ต้องแก้ไขโค้ดโปรแกรม
	• หัวใจของโปรเจค: สถาปัตยกรรมที่เรียกว่า "พิมพ์เขียวอัจฉริยะ" (Intelligent Blueprint Architecture) ซึ่งทำให้ฟอร์มต่างๆ ไม่ได้ถูกเขียนโค้ดตายตัว (Hardcode) แต่ถูกสร้างขึ้นมาแบบไดนามิก (Dynamic) ตามโครงสร้างที่เก็บไว้ในฐานข้อมูล

2. สถาปัตยกรรมและเทคโนโลยี (Architecture & Technology Stack)
โปรเจคนี้เป็น Monorepo ที่แบ่งออกเป็น 2 ส่วนหลักคือ frontend และ backend
	• Frontend (ฝั่งหน้าบ้าน): พัฒนาด้วย React (ใช้ TypeScript)
		○ Build Tool: Vite - ทำให้การพัฒนารวดเร็วและทันสมัย
		○ Styling: Tailwind CSS - สำหรับการสร้าง UI ที่สวยงามและตอบสนองได้ดี (Responsive)
		○ Routing: React Router DOM - จัดการการเปลี่ยนหน้าเว็บ
		○ Form Management: React Hook Form - เป็น "สมอง" หลักในการจัดการ State ของฟอร์มที่ซับซ้อน
		○ Data Fetching: Axios - ใช้ในการสื่อสารกับ Backend API
		○ UI Components: TanStack Table (สำหรับตารางข้อมูลขั้นสูง), React Beautiful DnD (สำหรับลากและวาง), SweetAlert2 (สำหรับกล่องข้อความยืนยัน)
	• Backend (ฝั่งหลังบ้าน): พัฒนาด้วย Node.js
		○ Framework: Express.js - จัดการเรื่อง API Routing และ Middleware
		○ Database Driver: mssql - สำหรับการเชื่อมต่อและส่งคำสั่งไปยัง SQL Server
		○ Authentication: JSON Web Tokens (JWT) - สำหรับการยืนยันตัวตนผู้ใช้
	• Database (ฐานข้อมูล): Microsoft SQL Server

3. ฐานข้อมูล (Database Schema)
ฐานข้อมูลคือรากฐานที่สำคัญที่สุดของสถาปัตยกรรม "พิมพ์เขียวอัจฉริยะ" ประกอบด้วยตารางหลักๆ 3 กลุ่ม:
กลุ่มที่ 1: Master Template (พิมพ์เขียว)
เป็นกลุ่มที่ใช้เก็บ "โครงสร้าง" ของฟอร์มที่ Admin สามารถแก้ไขได้
	• Form_Master_Templates: เปรียบเสมือน "หน้าปกของพิมพ์เขียว" แต่ละเวอร์ชัน เก็บข้อมูลหลักๆ เช่น template_name, version, และ is_latest เพื่อบอกว่าเวอร์ชันไหนคือเวอร์ชันล่าสุด
	• Form_Master_Items: เปรียบเสมือน "เนื้อหาของพิมพ์เขียว" เก็บโครงสร้างของแต่ละแถว/ไอเท็มในฟอร์ม
		○ คอลัมน์ที่สำคัญที่สุด: config_json คอลัมน์นี้เก็บข้อมูลโครงสร้างทั้งหมดของไอเท็มนั้นๆ ในรูปแบบ JSON (เช่น ชื่อ Label, ประเภท Input, กฎ Validation) ทำให้มีความยืดหยุ่นสูงมาก
กลุ่มที่ 2: Form Submission (ข้อมูลที่ผู้ใช้กรอก)
เป็นกลุ่มที่ใช้เก็บ "ข้อมูล" ที่ผู้ใช้ทั่วไปบันทึกเข้ามาผ่านฟอร์ม
	• Form_Submissions: เปรียบเสมือน "หน้าปกของรายงานที่บันทึกแล้ว" เก็บข้อมูลทั่วไปเช่น lot_no, submitted_by, และ submitted_at
	• Form_Submission_Data: เปรียบเสมือน "เนื้อหาของรายงาน"
		○ คอลัมน์ที่สำคัญที่สุด: form_data_json เก็บข้อมูลทั้งหมดที่ผู้ใช้กรอกในฟอร์มนั้นๆ เป็น JSON ก้อนเดียว ทำให้รองรับฟอร์มที่มีโครงสร้างต่างกันได้ในตารางเดียว
กลุ่มที่ 3: Versioning System (ระบบเวอร์ชันสำหรับข้อมูลที่บันทึก) - **[UPDATED 2026]**
เป็นกลุ่มที่ฉลาดที่สุด ทำหน้าที่ "ประทับตรา" ว่าข้อมูลที่บันทึกแต่ละครั้ง ใช้พิมพ์เขียวเวอร์ชันไหน
	• Form_Version_Sets: ทำหน้าที่เป็น "สารบัญชุดเวอร์ชัน"
		○ **Logic ใหม่:** ระบบจะค้นหาและจับคู่ Template เวอร์ชันล่าสุดที่มีผลบังคับใช้ (Active) ตามวันที่ปัจจุบัน
		○ **Strict Matching:** ระบบป้องกันการนำ Version Set ที่มีข้อมูลซ้ำซ้อนมาใช้ โดยจะสร้าง Version Set ใหม่ทันทีหากพบความผิดปกติ
	• Form_Version_Set_Items: บอกว่าใน "สารบัญ" แต่ละชุด (แต่ละ version_set_id) ประกอบด้วย template_id (พิมพ์เขียวเวอร์ชันเฉพาะ) อะไรบ้าง
	• **Submission State Behavior:**
		○ **Draft/Rejected:** ระบบจะอัปเดต Version ให้อัตโนมัติเมื่อกด Save เพื่อให้ User ได้ใช้ฟอร์มล่าสุดเสมอ
		○ **Approved:** ระบบจะ **ล็อค** Version Set นั้นไว้ ไม่ให้เปลี่ยนแปลง เพื่อรักษาประวัติข้อมูล (History) ให้ตรงกับตอนอนุมัติ
	ทำไมต้องมีกลุ่มที่ 3? เพื่อให้แน่ใจว่าเมื่อ Admin แก้ไขโครงสร้างฟอร์มในอนาคต ข้อมูลเก่าที่เคยบันทึกไว้จะยังคงสามารถแสดงผลได้อย่างถูกต้องตามโครงสร้าง ณ วันที่บันทึกเสมอ และข้อมูลที่ Approved แล้วจะไม่ถูกเปลี่ยนโครงสร้างตาม Master ตัวใหม่

4. Backend (หลังบ้าน) - การทำงานของ API
Backend ทำหน้าที่เป็นตัวกลางระหว่าง Frontend และฐานข้อมูล มี API Endpoint ที่สำคัญดังนี้:
	• /api/auth:
		○ POST /login: รับ userId และ password มาตรวจสอบกับฐานข้อมูล ถ้าถูกต้องจะสร้าง JWT Token และส่งข้อมูลผู้ใช้กลับไป.
	• /api/master:
		○ GET /templates: ดึงรายชื่อ Master Template ทั้งหมดมาแสดงในหน้า Editor โดยจัดกลุ่มตาม Category.
		○ GET /template/:templateName/latest: ดึง "พิมพ์เขียว" (items) ของ Template เวอร์ชันล่าสุด.
		○ POST /template/update: Endpoint ที่สำคัญที่สุดของ Admin รับข้อมูล Template ที่ถูกแก้ไข (ทั้งลำดับและเนื้อหา) จากนั้นจะทำการ "ปิด" เวอร์ชันเก่า และ "สร้าง" Template เวอร์ชันใหม่ทั้งหมดลงในฐานข้อมูล.
	• /api/submissions:
		○ POST /: Endpoint สำหรับการบันทึกฟอร์ม มี Logic อัจฉริยะในการ "ค้นหาหรือสร้าง" version_set_id ที่ถูกต้อง ก่อนที่จะบันทึกข้อมูลลง Form_Submissions และ Form_Submission_Data.
		○ GET /: ดึงรายการ Report ทั้งหมดสำหรับหน้า ReportHistory.
		○ GET /:id: ดึงข้อมูล Report เดียวแบบละเอียด โดยจะดึงทั้ง "ข้อมูลที่กรอก" และ "พิมพ์เขียวเวอร์ชันที่ถูกต้อง" กลับมาคู่กันเสมอ.
		○ DELETE /:id: ลบข้อมูล Report โดยใช้ Transaction เพื่อให้แน่ใจว่าข้อมูลถูกลบจาก 2 ตารางพร้อมกัน.

5. Frontend (หน้าบ้าน) - ส่วนประกอบที่สำคัญ
Frontend ถูกออกแบบมาให้เป็นสัดส่วนและนำกลับมาใช้ใหม่ได้ง่าย
ส่วนของผู้ใช้ทั่วไป (User)
	• หน้ากรอกฟอร์ม (BZ_Form/index.tsx):
		○ เป็นฟอร์มแบบหลายขั้นตอน (Multi-step) เพื่อลดความน่ากลัวของฟอร์มยาวๆ
		○ FormStep2.tsx และ FormStep3.tsx เป็น "Component อัจฉริยะ" ที่จะยิง API ไปขอ "พิมพ์เขียว" จาก Backend แล้วใช้ข้อมูล JSON นั้นมา "วาด" หน้าตาฟอร์มและสร้างกฎ Validation ขึ้นมาเองแบบไดนามิก.
	• หน้าประวัติ (ReportHistory.tsx):
		○ ใช้ TanStack Table เพื่อแสดงข้อมูลทั้งหมดในรูปแบบตารางที่ทรงพลัง.
		○ มีความสามารถในการ ค้นหา (Search) และ กรองตามวันที่ (Date Filter).
		○ มีปุ่มสำหรับ ดูรายละเอียด และ ลบ ข้อมูล (พร้อมกล่องข้อความยืนยันจาก SweetAlert2).
	• หน้าดูรายละเอียด (ReportDetailDispatcher.tsx และ BZFormViewer.tsx):
		○ เป็นตัวอย่างของการ "นำ Component กลับมาใช้ซ้ำ (Reusability)" ที่ดีที่สุด
		○ ReportDetailDispatcher ทำหน้าที่เป็น "ตัวจ่ายงาน" ที่จะดึงข้อมูลมาก่อน แล้วส่งต่อไปให้ Component ที่ถูกต้อง
		○ BZFormViewer จะนำ FormStep 1-4 (ตัวเดียวกับที่ใช้กรอกฟอร์ม) กลับมาใช้ใหม่ แต่ส่ง Prop isReadOnly={true} เข้าไป ทำให้ฟอร์มแสดงผลข้อมูลได้เหมือนตอนกรอกทุกประการ แต่ไม่สามารถแก้ไขได้.
ส่วนของผู้ดูแลระบบ (Admin)
	• หน้า Master Editor (FormMasterEditor.tsx):
		○ เป็น "ห้องควบคุม" ที่ Admin สามารถเลือก Category และ Template ที่ต้องการแก้ไขได้.
		○ สามารถ ลากและวาง (Drag and Drop) เพื่อจัดลำดับไอเท็มใหม่ได้.
		○ มีปุ่ม "Edit" เพื่อเปิด EditItemModal.tsx สำหรับแก้ไขรายละเอียดและกฎ Validation ของแต่ละไอเท็ม.
		○ ปุ่ม "Save Changes" จะปรากฏขึ้นก็ต่อเมื่อมีการเปลี่ยนแปลงเกิดขึ้นจริง และจะส่งข้อมูลทั้งหมดไปให้ Backend สร้างเป็นเวอร์ชันใหม่.
