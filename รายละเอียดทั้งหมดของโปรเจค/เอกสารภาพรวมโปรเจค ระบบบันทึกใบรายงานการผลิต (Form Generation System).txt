เอกสารภาพรวมโปรเจค: ระบบบันทึกProduction Report (Form Generation System)
1. ภาพรวมและเป้าหมายหลัก (Project Overview & Goal)
โปรเจคนี้คือ เว็บแอปพลิเคชัน Full-stack ที่ถูกสร้างขึ้นมาเพื่อเปลี่ยนกระบวนการบันทึก "Production Report" จากเดิมที่ใช้โปรแกรม Excel มาสู่ระบบดิจิทัลที่ทันสมัย, ยืดหยุ่น, และพร้อมสำหรับการขยายผลในอนาคต
	• เป้าหมายหลัก: สร้างระบบที่ผู้ใช้ทั่วไปสามารถ "กรอก" และ "ดู" Production Reportได้อย่างง่ายดาย ในขณะที่ผู้ดูแลระบบ (Admin) สามารถ "สร้าง" และ "แก้ไข" โครงสร้างของฟอร์มเหล่านั้นได้ด้วยตัวเอง โดยไม่ต้องแก้ไขโค้ดโปรแกรม
	• หัวใจของโปรเจค: สถาปัตยกรรมที่เรียกว่า "พิมพ์เขียวอัจฉริยะ" (Intelligent Blueprint Architecture) ซึ่งทำให้ฟอร์มต่างๆ ไม่ได้ถูกเขียนโค้ดตายตัว (Hardcode) แต่ถูกสร้างขึ้นมาแบบไดนามิก (Dynamic) ตามโครงสร้างที่เก็บไว้ในฐานข้อมูล

2. สถาปัตยกรรมและเทคโนโลยี (Architecture & Technology Stack)
โปรเจคนี้เป็น Monorepo ที่แบ่งออกเป็น 2 ส่วนหลักคือ frontend และ backend
	• Frontend (ฝั่งหน้าบ้าน): พัฒนาด้วย React (ใช้ TypeScript)
		○ Build Tool: Vite - ทำให้การพัฒนารวดเร็วและทันสมัย
		○ Styling: Tailwind CSS - สำหรับการสร้าง UI ที่สวยงามและตอบสนองได้ดี (Responsive)
		○ Routing: React Router DOM - จัดการการเปลี่ยนหน้าเว็บ
		○ Form Management: React Hook Form - เป็น "สมอง" หลักในการจัดการ State ของฟอร์มที่ซับซ้อน
		○ Data Fetching: Axios - ใช้ในการสื่อสารกับ Backend API
		○ UI Components: TanStack Table (สำหรับตารางข้อมูลขั้นสูง), React Beautiful DnD (สำหรับลากและวาง), SweetAlert2 (สำหรับกล่องข้อความยืนยัน)
	• Backend (ฝั่งหลังบ้าน): พัฒนาด้วย Node.js
		○ Framework: Express.js - จัดการเรื่อง API Routing และ Middleware
		○ Database Driver: mssql - สำหรับการเชื่อมต่อและส่งคำสั่งไปยัง SQL Server
		○ Authentication: JSON Web Tokens (JWT) - สำหรับการยืนยันตัวตนผู้ใช้
	• Database (ฐานข้อมูล): Microsoft SQL Server

3. ฐานข้อมูล (Database Schema)
ฐานข้อมูลคือรากฐานที่สำคัญที่สุดของสถาปัตยกรรม "พิมพ์เขียวอัจฉริยะ" ประกอบด้วยตารางหลักๆ 3 กลุ่ม:
กลุ่มที่ 1: Master Template (พิมพ์เขียว)
เป็นกลุ่มที่ใช้เก็บ "โครงสร้าง" ของฟอร์มที่ Admin สามารถแก้ไขได้
	• Form_Master_Templates: เปรียบเสมือน "หน้าปกของพิมพ์เขียว" แต่ละเวอร์ชัน เก็บข้อมูลหลักๆ เช่น template_name, version, และ is_latest เพื่อบอกว่าเวอร์ชันไหนคือเวอร์ชันล่าสุด
	• Form_Master_Items: เปรียบเสมือน "เนื้อหาของพิมพ์เขียว" เก็บโครงสร้างของแต่ละแถว/ไอเท็มในฟอร์ม
		○ คอลัมน์ที่สำคัญที่สุด: config_json คอลัมน์นี้เก็บข้อมูลโครงสร้างทั้งหมดของไอเท็มนั้นๆ ในรูปแบบ JSON (เช่น ชื่อ Label, ประเภท Input, กฎ Validation) ทำให้มีความยืดหยุ่นสูงมาก
กลุ่มที่ 2: Form Submission (ข้อมูลที่ผู้ใช้กรอก)
เป็นกลุ่มที่ใช้เก็บ "ข้อมูล" ที่ผู้ใช้ทั่วไปบันทึกเข้ามาผ่านฟอร์ม
	• Form_Submissions: เปรียบเสมือน "หน้าปกของรายงานที่บันทึกแล้ว" เก็บข้อมูลทั่วไปเช่น lot_no, submitted_by, และ submitted_at
	• Form_Submission_Data: เปรียบเสมือน "เนื้อหาของรายงาน"
		○ คอลัมน์ที่สำคัญที่สุด: form_data_json เก็บข้อมูลทั้งหมดที่ผู้ใช้กรอกในฟอร์มนั้นๆ เป็น JSON ก้อนเดียว ทำให้รองรับฟอร์มที่มีโครงสร้างต่างกันได้ในตารางเดียว
กลุ่มที่ 3: Versioning System (ระบบเวอร์ชันสำหรับข้อมูลที่บันทึก)
เป็นกลุ่มที่ฉลาดที่สุด ทำหน้าที่ "ประทับตรา" ว่าข้อมูลที่บันทึกแต่ละครั้ง ใช้พิมพ์เขียวเวอร์ชันไหน
	• Form_Version_Sets: ทำหน้าที่เป็น "สารบัญชุดเวอร์ชัน" จะสร้างแถวใหม่ก็ต่อเมื่อโครงสร้างของฟอร์ม (ชุดของ template_id) มีการเปลี่ยนแปลงเท่านั้น
	• Form_Version_Set_Items: บอกว่าใน "สารบัญ" แต่ละชุด (แต่ละ version_set_id) ประกอบด้วย template_id (พิมพ์เขียวเวอร์ชันเฉพาะ) อะไรบ้าง
	ทำไมต้องมีกลุ่มที่ 3? เพื่อให้แน่ใจว่าเมื่อ Admin แก้ไขโครงสร้างฟอร์มในอนาคต ข้อมูลเก่าที่เคยบันทึกไว้จะยังคงสามารถแสดงผลได้อย่างถูกต้องตามโครงสร้าง ณ วันที่บันทึกเสมอ

4. Backend (หลังบ้าน) - การทำงานของ API
Backend ทำหน้าที่เป็นตัวกลางระหว่าง Frontend และฐานข้อมูล มี API Endpoint ที่สำคัญดังนี้:
	• /api/auth:
		○ POST /login: รับ userId และ password มาตรวจสอบกับฐานข้อมูล ถ้าถูกต้องจะสร้าง JWT Token และส่งข้อมูลผู้ใช้กลับไป.
	• /api/master:
		○ GET /templates: ดึงรายชื่อ Master Template ทั้งหมดมาแสดงในหน้า Editor โดยจัดกลุ่มตาม Category.
		○ GET /template/:templateName/latest: ดึง "พิมพ์เขียว" (items) ของ Template เวอร์ชันล่าสุด.
		○ POST /template/update: Endpoint ที่สำคัญที่สุดของ Admin รับข้อมูล Template ที่ถูกแก้ไข (ทั้งลำดับและเนื้อหา) จากนั้นจะทำการ "ปิด" เวอร์ชันเก่า และ "สร้าง" Template เวอร์ชันใหม่ทั้งหมดลงในฐานข้อมูล.
	• /api/submissions:
		○ POST /: Endpoint สำหรับการบันทึกฟอร์ม มี Logic อัจฉริยะในการ "ค้นหาหรือสร้าง" version_set_id ที่ถูกต้อง ก่อนที่จะบันทึกข้อมูลลง Form_Submissions และ Form_Submission_Data.
		○ GET /: ดึงรายการ Report ทั้งหมดสำหรับหน้า ReportHistory.
		○ GET /:id: ดึงข้อมูล Report เดียวแบบละเอียด โดยจะดึงทั้ง "ข้อมูลที่กรอก" และ "พิมพ์เขียวเวอร์ชันที่ถูกต้อง" กลับมาคู่กันเสมอ.
		○ DELETE /:id: ลบข้อมูล Report โดยใช้ Transaction เพื่อให้แน่ใจว่าข้อมูลถูกลบจาก 2 ตารางพร้อมกัน.

5. Frontend (หน้าบ้าน) - ส่วนประกอบที่สำคัญ
Frontend ถูกออกแบบมาให้เป็นสัดส่วนและนำกลับมาใช้ใหม่ได้ง่าย
ส่วนของผู้ใช้ทั่วไป (User)
	• หน้ากรอกฟอร์ม (BZ_Form/index.tsx):
		○ เป็นฟอร์มแบบหลายขั้นตอน (Multi-step) เพื่อลดความน่ากลัวของฟอร์มยาวๆ
		○ FormStep2.tsx และ FormStep3.tsx เป็น "Component อัจฉริยะ" ที่จะยิง API ไปขอ "พิมพ์เขียว" จาก Backend แล้วใช้ข้อมูล JSON นั้นมา "วาด" หน้าตาฟอร์มและสร้างกฎ Validation ขึ้นมาเองแบบไดนามิก.
	• หน้าประวัติ (ReportHistory.tsx):
		○ ใช้ TanStack Table เพื่อแสดงข้อมูลทั้งหมดในรูปแบบตารางที่ทรงพลัง.
		○ มีความสามารถในการ ค้นหา (Search) และ กรองตามวันที่ (Date Filter).
		○ มีปุ่มสำหรับ ดูรายละเอียด และ ลบ ข้อมูล (พร้อมกล่องข้อความยืนยันจาก SweetAlert2).
	• หน้าดูรายละเอียด (ReportDetailDispatcher.tsx และ BZFormViewer.tsx):
		○ เป็นตัวอย่างของการ "นำ Component กลับมาใช้ซ้ำ (Reusability)" ที่ดีที่สุด
		○ ReportDetailDispatcher ทำหน้าที่เป็น "ตัวจ่ายงาน" ที่จะดึงข้อมูลมาก่อน แล้วส่งต่อไปให้ Component ที่ถูกต้อง
		○ BZFormViewer จะนำ FormStep 1-4 (ตัวเดียวกับที่ใช้กรอกฟอร์ม) กลับมาใช้ใหม่ แต่ส่ง Prop isReadOnly={true} เข้าไป ทำให้ฟอร์มแสดงผลข้อมูลได้เหมือนตอนกรอกทุกประการ แต่ไม่สามารถแก้ไขได้.
ส่วนของผู้ดูแลระบบ (Admin)
	• หน้า Master Editor (FormMasterEditor.tsx):
		○ เป็น "ห้องควบคุม" ที่ Admin สามารถเลือก Category และ Template ที่ต้องการแก้ไขได้.
		○ สามารถ ลากและวาง (Drag and Drop) เพื่อจัดลำดับไอเท็มใหม่ได้.
		○ มีปุ่ม "Edit" เพื่อเปิด EditItemModal.tsx สำหรับแก้ไขรายละเอียดและกฎ Validation ของแต่ละไอเท็ม.
6. Modernization & Code Standardization (Updates - Report History Refactoring)
ความคืบหน้าล่าสุด (มกราคม 2026) ได้มีการยกเครื่องสถาปัตยกรรมของหน้า "ประวัติการบันทึก" (Report History) ทั้งหมด (GEN_A, GEN_B, Ironpowder/Recycle) ใหม่ เพื่อแก้ปัญหาโค้ดซ้ำซ้อน (Code Duplication) และยกระดับการบำรุงรักษา (Maintainability) สู่มาตรฐานสากล

6.1 Unified Data Logic (ศูนย์รวม Logic การจัดการข้อมูล)
	• useReportHistoryData Hook:
		เราได้สร้าง Custom Hook กลางที่ชื่อว่า `useReportHistoryData` ขึ้นมาทำหน้าที่จัดการ Data Lifecycle ทั้งหมด:
		○ **Smart Fetching:** สามารถเลือกดึงข้อมูลจาก Service ที่ถูกต้องอัตโนมัติ (เช่นถ้า Category เป็น 'Recycle' จะดึงจาก `ironpowderService`, ถ้าเป็น GEN_A/B จะดึงจาก `submissionService`)
		○ **Unified Data Mapping:** แปลงโครงสร้างข้อมูลจาก Backend ที่อาจแตกต่างกัน (เช่น `created_at` vs `report_date`) ให้เป็น format กลาง `SubmissionData` ที่ UI เข้าใจได้ทันที
		○ **Real-time Synchronization:** รวม Logic การเชื่อมต่อ Socket.io ไว้ที่เดียว เมื่อมีการเพิ่ม/ลบ ข้อมูล ทุกหน้าจะอัปเดตอัตโนมัติโดยไม่ต้องเขียนโค้ดซ้ำในแต่ละหน้า

6.2 Reusable UI Components (องค์ประกอบทาง UI ที่ใช้ร่วมกัน)
	• ReportTableToolbar (Dynamic Toolbar):
		Toolbar อัจฉริยะที่ไม่ได้ Hardcode ค่าตัวกรองอีกต่อไป แต่รับค่า `availableForms` (รายการฟอร์ม) และ `createLink` (ลิงก์สร้างรายงาน) เป็น Props ทำให้ Component เดียวสามารถใช้ได้กับทุกแผนก (GEN A, B, Recycle) อย่างยืดหยุ่น
	• ReportTableColumns (Centralized Column Definition):
		นิยามคอลัมน์ของตารางถูกย้ายมาไว้ที่เดียว ทำให้การแก้ไขการแสดงผล (เช่น ปรับ format วันที่ หรือเปลี่ยนสี Status Chip) มีผลกับทุกหน้าทันที
		○ **Intelligent Routing:** ปุ่ม View/Edit ในตารางมีความฉลาดในการตรวจสอบ Category เพื่อ Direct ผู้ใช้ไปยัง URL ที่ถูกต้อง (เช่น `/reports/view/...` หรือ `/reports/view/recycle/...`) อัตโนมัติ
	• TablePagination:
		แยกส่วนควบคุมการเปลี่ยนหน้า (Pagination) ออกมาเป็น Component อิสระ เพื่อลดความซับซ้อนของหน้าหลัก

6.3 UX/UI & Performance Enhancements (การปรับปรุงประสบการณ์ผู้ใช้งาน)
	• Print Button Loading State:
		เพิ่มกลไกป้องกันการกดปุ่ม Print ซ้ำซ้อน โดยจะแสดง Loading Spinner หมุนอัตโนมัติขณะรอ Backend สร้างไฟล์ PDF และ Disable ปุ่มชั่วคราว ช่วยลดภาระ Server และให้ Feedback ที่ชัดเจนกับผู้ใช้
	• Codebase Cleanliness:
		ลดจำนวนบรรทัดในไฟล์หน้าหลัก (เช่น `ReportHistory_GEN_A.tsx`) ลงกว่า 50% ทำให้โค้ดอ่านง่ายและดูแลรักษาง่ายขึ้นสำหรับนักพัฒนาในอนาคต

สิ่งที่ทำไปนี้ช่วยให้การเพิ่มหน้า Report ใหม่ในอนาคต (เช่น GEN_C) สามารถทำได้รวดเร็วเพียงแค่เรียกใช้ Hook และ Component เหล่านี้ โดยแทบไม่ต้องเขียน Logic ใหม่เลย
