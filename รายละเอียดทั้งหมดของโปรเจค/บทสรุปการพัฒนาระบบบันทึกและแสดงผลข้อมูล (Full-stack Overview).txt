บทสรุปการพัฒนาระบบบันทึกและแสดงผลข้อมูล (Full-stack Overview)
เป้าหมายหลักของเราคือการสร้างระบบที่สมบูรณ์สำหรับ "สร้าง" (Create) และ "อ่าน" (Read) ใบรายงานการผลิตโดยยึดหลักสถาปัตยกรรม "พิมพ์เขียวอัจฉริยะ" ที่ยืดหยุ่นและพร้อมสำหรับการขยายตัวในอนาคต
ส่วนที่ 1: การวางรากฐาน (Database & Backend)
เราเริ่มต้นด้วยการสร้าง "โครงสร้างพื้นฐาน" ที่แข็งแรงเพื่อรองรับข้อมูลทั้งหมด
1.1 ฐานข้อมูล (SQL Server)
เราได้เพิ่มตารางใหม่ 4 ตาราง ซึ่งแต่ละตารางมีหน้าที่เฉพาะเจาะจง:
	• Form_Version_Sets: ทำหน้าที่เป็น "สารบัญชุดเวอร์ชัน" จะสร้างแถวใหม่ก็ต่อเมื่อโครงสร้างของฟอร์ม (พิมพ์เขียว) มีการเปลี่ยนแปลงเท่านั้น
	• Form_Version_Set_Items: บอกว่าใน "สารบัญ" แต่ละชุด ประกอบด้วย template_id (พิมพ์เขียวเวอร์ชันเฉพาะ) อะไรบ้าง
	• Form_Submissions: เปรียบเสมือน "หน้าปก" ของเอกสารที่บันทึก โดยมีการ "ประทับตรา" ด้วย version_set_id เพื่ออ้างอิงถึงโครงสร้างฟอร์มที่ใช้ ณ เวลานั้น
	• Form_Submission_Data: เก็บ "เนื้อหา" ของฟอร์มทั้งหมดในรูปแบบ JSON ก้อนเดียว ทำให้มีความยืดหยุ่นสูงมาก
1.2 Backend API (Node.js & Express)
เราได้สร้างและอัปเกรด API ในฝั่ง Backend เพื่อจัดการกับข้อมูล:
	• POST /api/submissions: Endpoint สำหรับ "สร้าง" ข้อมูลใหม่ โดยมี Logic อัจฉริยะในการ "ค้นหาหรือสร้าง" version_set_id ก่อนที่จะบันทึกข้อมูลลง Form_Submissions และ Form_Submission_Data
	• GET /api/submissions: Endpoint สำหรับ "อ่าน" ข้อมูลทั้งหมดในรูปแบบรายการ เพื่อใช้ในหน้า "Report History"
	• GET /api/submissions/:id: Endpoint สำหรับ "อ่าน" ข้อมูลเพียงรายการเดียวแบบละเอียด โดยจะดึงทั้ง "ข้อมูลที่กรอก" และ "พิมพ์เขียวเวอร์ชันที่ถูกต้อง" กลับมาคู่กันเสมอ

ส่วนที่ 2: การเชื่อมต่อและการจัดระเบียบ (Frontend Infrastructure)
ก่อนที่จะเริ่มสร้างหน้าเว็บ เราได้วางรากฐานที่สำคัญในฝั่ง Frontend เพื่อให้การพัฒนาราบรื่นและมีมาตรฐาน
2.1 การตั้งค่า Proxy (vite.config.js)
	• ปัญหาที่แก้ไข: แก้ปัญหา Network Error และ CORS ที่เกิดจากการที่ Frontend (localhost:5173) ไม่สามารถเรียก API ของ Backend (localhost:4000) ได้โดยตรง
	• สิ่งที่เราทำ: เราตั้งค่า Proxy ให้ Vite Dev Server ทำหน้าที่เป็น "ตัวกลาง" เมื่อมีการเรียก /api/... จาก Frontend, Vite จะส่งคำขอนั้นต่อไปยัง Backend ให้โดยอัตโนมัติ ทำให้การเชื่อมต่อราบรื่นและปลอดภัย
2.2 การสร้าง Service Layer (/services)
	• ปัญหาที่แก้ไข: หลีกเลี่ยงการเขียนโค้ดเรียก axios ซ้ำซ้อนและกระจัดกระจายอยู่ในหลายๆ Component
	• สิ่งที่เราทำ: เราสร้างไฟล์ Service ขึ้นมา 3 ไฟล์:
		○ apiService.ts: เป็นศูนย์กลางการเชื่อมต่อ axios
		○ submissionService.ts: รวมฟังก์ชันที่เกี่ยวกับการ "สร้าง" และ "อ่าน" ข้อมูลที่บันทึกไว้
		○ formService.ts: รวมฟังก์ชันที่เกี่ยวกับการดึง "พิมพ์เขียว"

ส่วนที่ 3: การสร้างฟีเจอร์ "บันทึกข้อมูล" (Create Feature)
เราได้ "อัปเกรด" ฟอร์ม BZ_Form เดิมให้สามารถบันทึกข้อมูลได้จริง
3.1 การอัปเกรด BZ_Form/index.tsx
	• เพิ่ม State: เราเพิ่ม isSubmitting (สำหรับควบคุมปุ่ม) และ loadedTemplates (สำหรับเก็บ ID พิมพ์เขียว)
	• แก้ปัญหา Loop ไม่รู้จบ: เราใช้ useCallback เพื่อสร้างฟังก์ชัน handleTemplateLoaded ที่เสถียรและไม่ถูกสร้างใหม่ทุกครั้งที่ re-render ซึ่งเป็นการแก้ปัญหา Maximum update depth exceeded ที่เคยเกิดขึ้น
	• เชื่อมต่อ Component ลูก: เราส่ง onTemplateLoaded เป็น Prop ลงไปให้ FormStep2 และ FormStep3 เพื่อให้ลูกสามารถส่งข้อมูล template_id กลับขึ้นมาให้แม่ได้
	• อัปเกรด onSubmit: เราเปลี่ยน onSubmit เดิมให้กลายเป็น Logic การบันทึกข้อมูลที่สมบูรณ์ โดยมีการสร้าง submissionPayload, เรียกใช้ Service, และแสดงผลลัพธ์ด้วย fireToast

ส่วนที่ 4: การสร้างฟีเจอร์ "แสดงผลข้อมูล" (Read Feature)
หลังจากบันทึกข้อมูลได้แล้ว เราได้สร้างระบบเพื่อให้ผู้ใช้สามารถย้อนกลับมาดูข้อมูลได้
4.1 หน้ารายการ (ReportHistory.tsx)
	• สิ่งที่เราทำ: สร้างหน้าใหม่ทั้งหมดที่ useEffect จะเรียกใช้ getAllSubmissions จาก Service เพื่อดึงรายการทั้งหมดมาแสดงในรูปแบบตาราง
	• ฟีเจอร์เพิ่มเติม: เราได้เพิ่มปุ่ม "สร้างรายงานใหม่" ที่ลิงก์กลับไปหน้าฟอร์ม และสร้าง ลิงก์สำหรับดูรายละเอียด (/reports/view/:id) ในแต่ละแถวของตาราง
4.2 การจัดระเบียบหน้าแสดงผล
	• ปัญหาที่แก้ไข: ป้องกันความสับสนในอนาคตเมื่อมีฟอร์ม 26 แบบ
	• สิ่งที่เราทำ: เราได้จัดโครงสร้างโฟลเดอร์ใหม่ โดยสร้าง /pages/Reports ขึ้นมา และวางแผนให้หน้าแสดงรายละเอียดของแต่ละฟอร์มถูกแยกเก็บไว้ในโฟลเดอร์ของตัวเอง (เช่น /BZ/ReportDetailBZ.tsx)
4.3 หน้าแสดงรายละเอียด (ReportDetailDispatcher.tsx และ ReportDetailBZ.tsx)
	• ReportDetailDispatcher.tsx (ตัวจ่ายงาน):
		○ เราสร้าง Component อัจฉริยะนี้ขึ้นมาเพื่อทำหน้าที่เป็น "ผู้จัดการ" ของหน้ารายละเอียด
		○ มันจะดึง id จาก URL, เรียก API getSubmissionById, และตรวจสอบ form_type ของข้อมูล
		○ จากนั้น มันจะ "จ่ายงาน" ต่อไปให้ Component ที่ถูกต้อง (ในกรณีนี้คือ ReportDetailBZ)
	• ReportDetailBZ.tsx และ BZFormViewer.tsx (การนำฟอร์มกลับมาใช้ใหม่):
		○ แนวคิดสำคัญ: แทนที่จะสร้างหน้าแสดงผลใหม่ทั้งหมด เราได้นำ Component FormStep 1-4 ที่ใช้ในการ "สร้าง" ฟอร์มกลับมาใช้ซ้ำ
		○ BZFormViewer.tsx: เราสร้าง Component นี้ขึ้นมาเพื่อ "ห่อหุ้ม" FormStep ทั้งหมด โดยรับ formData มาเติมลงในฟอร์มผ่าน react-hook-form และส่ง Prop isReadOnly={true} ลงไป
		○ ผลลัพธ์: ทำให้หน้า "ดูรายละเอียด" มีหน้าตาเหมือนกับฟอร์มตอนกรอกทุกประการ แต่ไม่สามารถแก้ไขได้ ซึ่งเป็นประสบการณ์ใช้งานที่ดีและบำรุงรักษาง่ายมาก
ทั้งหมดนี้คือภาพรวมการทำงานที่เราได้ทำร่วมกันจนสำเร็จครับ! ตอนนี้คุณมีระบบ Create และ Read ที่แข็งแรง, ยืดหยุ่น, และพร้อมที่จะต่อยอดไปสู่ฟีเจอร์ "แก้ไข" (Update) ต่อไปแล้วครับ

ส่วนที่ 5: การปรับปรุงระบบและฟีเจอร์เพิ่มเติม (Enhancements & Fixes)
หลังจากวางรากฐานเสร็จสิ้น เราได้ดำเนินการปรับปรุงระบบให้สมบูรณ์ยิ่งขึ้น โดยเน้นความถูกต้องของข้อมูล (Data Integrity) และประสบการณ์ผู้ใช้ (User Experience):

5.1 ระบบการส่งงานใหม่ (Resubmit Logic Revision)
	• ปัญหา: การส่งงานใหม่เดิมยังลบข้อมูลไม่หมดทำให้สถานะค้าง
	• สิ่งที่เราทำ: ปรับปรุง Logic ใน ironpowder.service.js และ submission.service.js ให้ทำการ "Reset" ข้อมูลอย่างหมดจดเมื่อกด Resubmit:
		○ สถานะ (Status) -> "Pending"
		○ ผู้อนุมัติ (Approver) -> NULL
		○ วันที่แก้ไข (Updated At) -> NULL (เพื่อให้หน้าจอไม่แสดงวันที่ค้าง)
		○ ลบ Logs เดิมทิ้งทั้งหมด เพื่อให้ Flow การอนุมัติเริ่มต้นใหม่ได้ 100%

5.2 การตรวจสอบความถูกต้องของข้อมูล (Form Validation)
	• ปัญหา: ผู้ใช้สามารถข้ามการกรอกข้อมูลสำคัญใน Step 4 (Packing) ได้
	• สิ่งที่เราทำ: เพิ่ม validation rules ใน PackingResultTable_GENA/GENB ให้บังคับกรอกข้อมูลสำคัญ เช่น quantityOfProduct, diameter, meshPass40, และ remain ป้องกันข้อมูลขยะเข้าสู่ระบบ

5.3 การคำนวณเป้าหมายการผลิตขั้นสูง (Advanced ST Value Calculation)
	• ความต้องการ: ค่าเป้าหมาย (Standard Plan) ในฐานข้อมูลควรสะท้อนค่าจริงที่รวม NCR เข้าไปแล้ว
	• สิ่งที่เราทำ: พัฒนาระบบ Backend ให้มีความสามารถในการคำนวณขั้นสูง:
		○ สร้าง Helper Function calculateTotalStValue เพื่อคำนวณ "ค่าเป้าหมายสุทธิ" โดยนำ "Standard Plan จาก Master" + "NCR Value ที่ User กรอก"
		○ นำ Logic นี้ไปฝังไว้ในทุกจุดที่มีการบันทึก (Create, Update, Resubmit)
		○ แก้ไข Repository ให้บันทึกค่า st_target_value ที่คำนวณใหม่ลงฐานข้อมูล Form_Submission_Data จริงๆ ซึ่งจะช่วยให้การ Query รายงานในอนาคตแม่นยำขึ้นมาก

5.4 การแสดงผลวันที่และเวลา (Date & Timezone)
	• ปัญหา: วันที่แสดงผลผิดเพี้ยนไป 1 วันเนื่องจากปัญหา Timezone
	• สิ่งที่เราทำ: ปรับระบบการแสดงผลวันที่ทั้งหมด (Approval Flow, History Pages) ให้ใช้ timeZone: 'UTC' อย่างชัดเจน เพื่อให้วันที่ที่ User เห็น ตรงกับวันที่ที่บันทึกใน Database เสมอ ไม่ว่าจะเปิดจากเครื่องไหน
