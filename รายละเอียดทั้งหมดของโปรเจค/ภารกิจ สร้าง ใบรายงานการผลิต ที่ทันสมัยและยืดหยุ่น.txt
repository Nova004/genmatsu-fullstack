ภารกิจ: สร้าง "Production Report" (BZ_Form) ที่ทันสมัยและยืดหยุ่น
โจทย์เริ่มต้น: นายมีฟอร์มเก่าที่เป็น HTML แบบดั้งเดิม และต้องการแปลงมันให้กลายเป็นเว็บแอปพลิเคชันสมัยใหม่ที่ทำงานบนโปรเจค Full-stack (React + Node.js) ของนาย

ระยะที่ 1: การก่อร่างสร้างฟอร์ม (Foundation & Structure)
ขั้นตอนที่ 1.1: สร้างฟอร์มหลายขั้นตอน (Multi-step Form)
	• ปัญหา: ฟอร์มทั้งหมดมีความยาวมาก ถ้าแสดงในหน้าเดียวจะดูน่ากลัวและใช้งานยาก
	• วิธีแก้: เราตัดสินใจแบ่งฟอร์มออกเป็น 4 สเต็ป (ตอนแรกนึกว่า 5) โดยใช้ React State เข้ามาช่วย
		○ ในไฟล์ index.tsx (ตัวจัดการหลัก) เราสร้าง const [step, setStep] = useState(1); เพื่อเป็น "หน่วยความจำ" ว่าตอนนี้ผู้ใช้กำลังกรอกข้อมูลอยู่หน้าไหน
		○ เราสร้าง Component สำหรับแต่ละหน้า (FormStep1, FormStep2 ฯลฯ)
		○ เราใช้เทคนิค Conditional Rendering ({step === 1 && <FormStep1 />}) เพื่อแสดงผล Component ที่ถูกต้องตามค่า step ปัจจุบัน
ขั้นตอนที่ 1.2: จัดการข้อมูลด้วย react-hook-form
	• ปัญหา: การจัดการข้อมูลในฟอร์มที่มีช่องกรอกเยอะๆ ด้วย useState ธรรมดาจะซับซ้อนและวุ่นวายมาก
	• วิธีแก้: เรานำ Library ที่ทรงพลังอย่าง react-hook-form เข้ามาเป็น "สมอง" ของฟอร์ม
		○ เราใช้ useForm() ใน index.tsx เพื่อสร้างเครื่องมือทั้งหมด (register, handleSubmit, watch, setValue, errors)
		○ เราส่งฟังก์ชัน register เป็น props เข้าไปให้แต่ละสเต็ป เพื่อให้ทุกช่อง Input สามารถ "ลงทะเบียน"ตัวเองกับ "สมอง" หลักได้
ขั้นตอนที่ 1.3: จัดระเบียบโค้ด (Refactoring for Scalability)
	• ปัญหา: ตอนแรกเราเขียนทุกอย่างรวมกันในไฟล์เดียว ซึ่งนายทักขึ้นมาได้ถูกต้องว่า "ถ้ามี 26 ฟอร์มจะทำยังไง?"
	• วิธีแก้: เราทำการ "ผ่าตัด" ครั้งใหญ่ โดยยึดหลักการ Separation of Concerns
		○ สร้าง pages/BZ_Form: เป็นโฟลเดอร์สำหรับเก็บหน้าจอของฟอร์ม BZ โดยเฉพาะ
			§ index.tsx: เป็นไฟล์ "ผู้จัดการ" ที่ควบคุม State และการแสดงผล
			§ FormStep1.tsx, FormStep2.tsx, ...: เป็นไฟล์ที่เก็บ "หน้าตา" (UI) ของแต่ละสเต็ปเท่านั้น
			§ types.ts: เป็นไฟล์ "พิมพ์เขียว" ที่เก็บ interface ทั้งหมด เพื่อให้ทุกไฟล์เข้าใจโครงสร้างข้อมูลตรงกัน
		○ สร้าง components/forms: เป็น "กล่องเครื่องมือ" ที่เก็บชิ้นส่วนที่สามารถใช้ซ้ำได้ในฟอร์มอื่นๆ (เช่น EmployeeInputRow, PalletTable)

ระยะที่ 2: การเชื่อมต่อโลก Frontend และ Backend
ขั้นตอนที่ 2.1: ทำให้ฟอร์ม "มีชีวิต" (Fetching User Data)
	• เป้าหมาย: ในสเต็ปที่ 1 เมื่อผู้ใช้กรอก "รหัสพนักงาน" จะต้องดึง "ชื่อ" กับ "เลขที่" มาแสดงอัตโนมัติ
	• วิธีทำ (Backend):
		○ เราสร้าง "ท่อส่งข้อมูล" (API Endpoint) ใหม่ คือ GET /api/users/:id
		○ เราสร้าง user.controller.js เพื่อเขียน Logic การเชื่อมต่อฐานข้อมูล MSSQL และใช้คำสั่ง SELECT เพื่อค้นหาข้อมูลพนักงานจากรหัสที่ส่งมา
	• วิธีทำ (Frontend):
		○ ใน Component EmployeeInputRow.tsx เราใช้ watch เพื่อ "แอบดู" ค่าในช่องรหัสพนักงานแบบ Real-time
		○ เราใช้ useEffect เป็น "ยามเฝ้าระวัง" ที่จะทำงานทุกครั้งที่ค่ารหัสเปลี่ยน
		○ ข้างใน useEffect เราใช้ fetch เพื่อยิง API ไปที่ Backend
		○ เมื่อได้ข้อมูลกลับมา เราก็ใช้ setValue เพื่อ "สั่ง" ให้ช่อง "ชื่อ" และ "เลขที่" แสดงผลข้อมูลนั้น
ขั้นตอนที่ 2.2: การแก้ไขปัญหา (Debugging)
	• เราเจอปัญหามากมายระหว่างทาง! ตั้งแต่ Cannot GET (ลืม Restart Server), is not a function (เรียกใช้ pool ผิดวิธี) ไปจนถึง Cannot find name (ลืม import Type)
	• วิธีแก้: เราค่อยๆ ไล่เช็คทีละจุด ตั้งแต่การดู Log ใน Terminal ของ Backend, การทดสอบ API โดยตรง, ไปจนถึงการตรวจสอบโค้ดในแต่ละไฟล์อย่างละเอียด จนสามารถแก้ไขปัญหาทั้งหมดได้

ระยะที่ 3: อัปเกรดสู่ "ฟอร์มไดนามิก" (The Master Plan)
ขั้นตอนที่ 3.1: สร้าง "โกดัง" สำหรับเก็บ "พิมพ์เขียว" (Database for Master)
	• เป้าหมาย: สร้างระบบที่ Admin สามารถแก้ไขโครงสร้างของสเต็ปที่ 2 (และ 3) ได้เอง โดยไม่ต้องแก้โค้ด
	• วิธีทำ (Backend):
		○ เราออกแบบและสร้างตารางใหม่ 2 ตาราง: Form_Master_Templates และ Form_Master_Items
		○ หัวใจหลัก: เราใช้คอลัมน์ config_json เพื่อเก็บ "พิมพ์เขียว" ของแต่ละแถวในรูปแบบ JSON ซึ่งทำให้มันยืดหยุ่นมากพอที่จะรองรับ Layout ที่ซับซ้อน (เช่น แถวที่มี 2 Input) และ "กฎ" การตรวจสอบ (Validation) ที่แตกต่างกันได้
		○ เราเขียน SQL Script เพื่อ INSERT ข้อมูล Master เริ่มต้นเข้าไป
ขั้นตอนที่ 3.2: สร้าง "ท่อส่งพิมพ์เขียว" (API for Master)
	• เป้าหมาย: สร้างเส้นทางให้ Frontend สามารถร้องขอ "พิมพ์เขียว" ล่าสุดได้
	• วิธีทำ (Backend):
		○ เราสร้าง API Endpoint ใหม่คือ GET /api/master/template/:template_name
		○ เราสร้าง master.controller.js ที่มี Logic การ SELECT ข้อมูลจาก 2 ตารางที่เราเพิ่งสร้าง และแปลง config_json ให้พร้อมใช้งานก่อนส่งกลับไป
ขั้นตอนที่ 3.3: ผ่าตัด FormStep2.tsx ให้ "ฉลาดขึ้น"
	• เป้าหมาย: ทำให้ FormStep2 สามารถสร้างตารางของตัวเองขึ้นมาได้ตาม "พิมพ์เขียว" ที่ได้รับ
	• วิธีทำ (Frontend):
		○ เราลบโค้ดตาราง "Raw Material Name" ที่เป็น Hardcode ทิ้งไป
		○ เราใช้ useState และ useEffect เพื่อยิง API ไปขอ "พิมพ์เขียว" จาก Backend มาเก็บไว้
		○ เราใช้ .map() เพื่อวนลูป "พิมพ์เขียว" ที่ได้มา แล้วใช้ switch (config.row_type) เพื่อ "วาด" ตารางแต่ละแถวขึ้นมาตาม row_type ที่ระบุไว้ใน JSON
ขั้นตอนที่ 3.4: เพิ่มระบบตรวจสอบค่าแบบไดนามิก (Dynamic Validation)
	• เป้าหมาย: ทำให้ระบบ Validation ทำงานตาม "กฎ" ที่ระบุไว้ใน "พิมพ์เขียว"
	• วิธีทำ (Backend):
		○ เรารัน SQL Script เพื่อ UPDATE config_json ของเรา โดยเพิ่ม Object validation ที่มี "กฎ" ต่างๆ เข้าไป (เช่น type, min, max, errorMessage)
	• วิธีทำ (Frontend):
		○ ใน index.tsx เราเพิ่ม mode: 'onChange' เข้าไปใน useForm เพื่อเปิดใช้งานการตรวจสอบแบบ Real-time
		○ ใน FormStep2.tsx เราสร้างฟังก์ชันผู้ช่วยชื่อ renderValidatedInput
		○ ฟังก์ชันนี้จะ "อ่าน" validation object จาก "พิมพ์เขียว" แล้วใช้ validate function ของ react-hook-form เพื่อสร้าง "กฎ" การตรวจสอบขึ้นมาแบบไดนามิก
		○ เรายังได้สร้าง customErrors State และ useEffect อีกก้อน เพื่อจัดการกับ Validation ของช่องที่ disabled และถูกคำนวณค่ามาโดยเฉพาะ
ผลลัพธ์สุดท้าย: ตอนนี้นายได้สร้างฟอร์ม 4 สเต็ปที่ซับซ้อนและทรงพลังมาก มันไม่ใช่แค่ฟอร์มธรรมดาๆ อีกต่อไป แต่มันคือ ระบบฟอร์มอัจฉริยะ ที่:
	• มีโครงสร้างโค้ดที่ดีเยี่ยม พร้อมสำหรับการต่อยอด
	• เชื่อมต่อกับ Backend เพื่อดึงข้อมูล User ได้
	• สามารถสร้างหน้าตาของตัวเองขึ้นมาได้ตาม "พิมพ์เขียว" ที่อยู่ในฐานข้อมูล
	• สามารถ "บังคับใช้กฎ" การตรวจสอบที่ซับซ้อนและแตกต่างกันได้ ซึ่งกฎเหล่านี้ก็มาจาก "พิมพ์เขียว" เช่นกัน
นี่คือทั้งหมดที่เราทำกันมาครับ! เป็นการเดินทางที่ยาวนาน แต่ผลลัพธ์ที่ได้นั้นคุ้มค่ามากครับ!
