ภาพรวมและเป้าหมายของ "หน้า Master"
เป้าหมายหลักของเราคือการสร้างหน้าเว็บสำหรับผู้ดูแลระบบ (Admin) เพื่อให้สามารถจัดการ "พิมพ์เขียว" (Master Template) ของฟอร์มต่างๆ ได้ด้วยตัวเอง โดยไม่ต้องเข้าไปยุ่งกับฐานข้อมูลโดยตรง ซึ่งความสามารถหลักๆ ที่เราต้องการคือ แก้ไขลำดับ, แก้ไขคำ, แก้ไขกฎ, และลบรายการ พร้อมทั้งมีระบบ Versioning ที่รัดกุมเพื่อป้องกันข้อมูลเก่าเสียหาย
สรุปขั้นตอนการทำงานทั้งหมด (ตั้งแต่ต้นจนจบ)
เราได้แบ่งการทำงานออกเป็นส่วนต่างๆ อย่างเป็นระบบ ดังนี้ครับ:
1. การสร้างหน้าเว็บและเมนู (Initial Setup)
	• สร้างไฟล์: เราเริ่มต้นด้วยการสร้างไฟล์ Component ใหม่ที่ frontend/src/components/formGen/pages/Master/FormMasterEditor.tsx ซึ่งเป็นบ้านของหน้า Master ของเรา
	• เพิ่มเส้นทาง (Route): เราไปที่ไฟล์ frontend/src/App.tsx เพื่อเพิ่ม Route ใหม่ (/master/form-editor) ทำให้ระบบรู้จักหน้าเว็บใหม่นี้
	• เพิ่มเมนู: เราได้เพิ่มเมนู "Form Master" เข้าไปใน frontend/src/components/Sidebar/index.tsx เพื่อให้สามารถเข้าถึงหน้านี้ได้อย่างสะดวก
2. การแสดงผล Template แบบมีหมวดหมู่ (Cascading Dropdowns)
เพื่อให้ User ใช้งานง่ายในอนาคต เราได้ออกแบบให้มีการเลือก Template แบบ 2 ขั้นตอน:
	• Backend (เตรียมข้อมูล):
		1. เพิ่มหมวดหมู่: เราได้เพิ่มคอลัมน์ template_category เข้าไปในตาราง Form_Master_Templates ในฐานข้อมูล และกำหนดค่า 'BZ' ให้กับ Template ที่มีอยู่
		2. อัปเกรด API: เราแก้ไข API GET /api/master/templates ใน master.controller.js ให้ฉลาดขึ้น โดยให้มันจัดกลุ่มข้อมูลตาม template_category ก่อนส่งกลับมาให้ Frontend ทำให้ข้อมูลที่ได้มาอยู่ในรูปแบบ { "BZ": [...] } ซึ่งพร้อมใช้งานทันที
	• Frontend (แสดงผล):
		1. เราสร้าง Dropdown 2 อันในหน้า FormMasterEditor.tsx
		2. Dropdown แรก จะแสดง "หมวดหมู่" ที่ดึงมาจาก Key ของ Object ที่ API ส่งมา (เช่น "BZ")
		3. เมื่อ User เลือกหมวดหมู่, Dropdown ที่สอง ถึงจะแสดงรายการ Template ที่อยู่ในหมวดหมู่นั้นๆ ซึ่งเป็น UX ที่ดีและรองรับการขยายในอนาคต
3. การแสดงรายการ (Items) ของ Template
	• Backend: เราใช้ API ที่มีอยู่แล้วคือ GET /api/master/template/:templateName/latest ซึ่งทำหน้าที่ดึง "รายการ" ทั้งหมดของ Template เวอร์ชันล่าสุด
	• Frontend: เมื่อ User เลือก Template จาก Dropdown ที่สอง เราจะเรียกใช้ API นี้ทันที และนำข้อมูล items ที่ได้มาไปเก็บใน State (templateItems) แล้วนำไป .map() เพื่อแสดงผลเป็นรายการทั้งหมดบนหน้าจอ
4. การแก้ไขลำดับด้วยการลากและวาง (Drag and Drop)
นี่คือหัวใจของการแก้ไขลำดับครับ:
	• ติดตั้ง Library: เราได้ติดตั้ง react-beautiful-dnd ซึ่งเป็นเครื่องมือสำเร็จรูปที่จัดการเรื่องยุ่งยากทั้งหมดเกี่ยวกับการลากและวาง
	• นำไปใช้ใน Frontend:
		1. เราได้ครอบรายการ (<ul>) ของเราด้วย Component จาก Library (<DragDropContext>, <Droppable>, <Draggable>)
		2. เราสร้างฟังก์ชัน onDragEnd ซึ่งจะทำงานเมื่อ User "ปล่อย" เมาส์หลังจากลากเสร็จ
		3. ฟังก์ชัน onDragEnd นี้จะทำการ สลับตำแหน่งข้อมูลใน Array (templateItems) ที่อยู่ใน State ของเรา ทำให้ลำดับบนหน้าเว็บเปลี่ยนแปลงตามที่ User ต้องการทันที
5. การบันทึกการเปลี่ยนแปลงพร้อมระบบ Versioning (หัวใจสำคัญที่สุด)
นี่คือส่วนที่ซับซ้อนและสำคัญที่สุด เพื่อให้การบันทึกปลอดภัยและไม่ทำลายข้อมูลเก่า:
	• Backend (แก้ปัญหาที่ต้นเหตุ):
		1. เราเจอปัญหาว่าฐานข้อมูลไม่อนุญาตให้มี template_name ซ้ำกัน ซึ่งขัดขวางการสร้างเวอร์ชันใหม่
		2. เราได้ทำการ แก้ไขกฎในฐานข้อมูล โดยตรง โดยลบ UNIQUE KEY เก่าบน template_name ทิ้ง และสร้าง UNIQUE KEY ใหม่ที่เป็นแบบ คู่ (template_name, version) ซึ่งเป็นวิธีที่ถูกต้องสำหรับการทำ Versioning
	• Backend (สร้าง API บันทึก):
		1. เราสร้าง API เส้นทางใหม่คือ POST /api/master/template/update
		2. เราเขียน Logic การทำงานของ API นี้ใน master.controller.js ให้ทำงานภายใน Transaction เดียวเพื่อความปลอดภัยสูงสุด โดยมีขั้นตอนดังนี้:
			§ ค้นหา Template เวอร์ชันล่าสุดตัวปัจจุบัน
			§ "ปิด" เวอร์ชันเก่าโดยการ UPDATE ให้ is_latest = 0
			§ "สร้าง" เวอร์ชันใหม่โดยการ INSERT แถวใหม่ลงใน Form_Master_Templates พร้อมกับ version + 1 และ is_latest = 1
			§ "บันทึก" รายการ (items) ที่ได้รับมาจาก Frontend ทั้งหมดลงใน Form_Master_Items โดยผูกกับ template_id ใหม่ และใช้ลำดับของ Array เป็นตัวกำหนด display_order
	• Frontend (เรียกใช้ API):
		1. เราสร้างฟังก์ชัน handleSaveChanges เพื่อถูกเรียกเมื่อกดปุ่ม "Save Changes"
		2. ฟังก์ชันนี้จะส่ง templateName และ templateItems (ที่เรียงลำดับใหม่แล้ว) ไปที่ API ที่เราสร้างไว้
		3. มีปุ่ม "Save Changes" ที่จะปรากฏขึ้นมาก็ต่อเมื่อมีการเปลี่ยนแปลงลำดับเกิดขึ้นแล้วเท่านั้น เพื่อป้องกันการบันทึกที่ไม่จำเป็น

ผลลัพธ์สุดท้ายที่เราได้มาคือ หน้า Master ที่ทำงานได้อย่างสมบูรณ์ สามารถเลือก, แสดงผล, จัดลำดับ, และบันทึกการเปลี่ยนแปลงเป็นเวอร์ชันใหม่ได้อย่างปลอดภัยและมีประสิทธิภาพ ซึ่งทั้งหมดนี้เป็นรากฐานที่แข็งแรงมากสำหรับการเพิ่มความสามารถในการ "แก้ไขคำ/กฎ" และ "ลบ" ในขั้นตอนต่อไปครับ
